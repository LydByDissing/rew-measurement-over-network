#!/bin/bash

# REW PulseAudio Loopback Device Manager
# Creates and manages virtual audio devices for REW measurements

set -e

# Configuration
DEVICE_NAME="REW_Network_Audio_Bridge"
DEVICE_DESCRIPTION="REW Network Audio Bridge"
CONFIG_FILE="$HOME/.rew-loopback"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[REW-Loopback]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Check if PulseAudio is available
check_pulseaudio() {
    if ! command -v pactl &> /dev/null; then
        error "pactl command not found. Please install PulseAudio."
        exit 1
    fi
    
    if ! pactl info &> /dev/null; then
        error "PulseAudio server is not running."
        exit 1
    fi
}

# Get module IDs from config file
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

# Save module IDs to config file
save_config() {
    cat > "$CONFIG_FILE" << EOF
# REW Loopback Device Configuration
# Generated automatically - do not edit manually
SINK_MODULE_ID="$SINK_MODULE_ID"
LOOPBACK_MODULE_ID="$LOOPBACK_MODULE_ID"
EOF
}

# Remove config file
remove_config() {
    if [ -f "$CONFIG_FILE" ]; then
        rm "$CONFIG_FILE"
    fi
}

# Check if device exists
device_exists() {
    # Check if sink exists
    if pactl list short sinks | grep -q "^[0-9]*[[:space:]]*$DEVICE_NAME[[:space:]]"; then
        return 0
    fi
    return 1
}

# Check if REW devices exist more thoroughly
rew_devices_exist() {
    # Check for any sinks with REW in the name (case insensitive)
    if pactl list short sinks | grep -i "rew" > /dev/null 2>&1; then
        return 0
    fi
    
    # Check config file for existing modules
    load_config
    if [ -n "$SINK_MODULE_ID" ] || [ -n "$LOOPBACK_MODULE_ID" ]; then
        # Verify the modules still exist
        if pactl list short modules | grep -E "^$SINK_MODULE_ID[[:space:]]|^$LOOPBACK_MODULE_ID[[:space:]]" > /dev/null 2>&1; then
            return 0
        fi
    fi
    
    return 1
}

# Get device status
get_device_status() {
    if device_exists; then
        local status=$(pactl list short sinks | grep "$DEVICE_NAME" | awk '{print $NF}')
        case "$status" in
            "RUNNING") echo "ACTIVE" ;;
            "IDLE") echo "READY" ;;
            *) echo "UNKNOWN ($status)" ;;
        esac
    else
        echo "NOT_FOUND"
    fi
}

# Create the virtual device
create_device() {
    log "Creating REW virtual audio device..."
    
    # Step 1: Create null-sink (this is what REW outputs to)
    log "Creating null-sink: $DEVICE_NAME"
    SINK_MODULE_ID=$(pactl load-module module-null-sink sink_name="$DEVICE_NAME")
    
    if [ -z "$SINK_MODULE_ID" ]; then
        error "Failed to create null-sink"
        exit 1
    fi
    
    log "Created null-sink with module ID: $SINK_MODULE_ID"
    
    # Step 1.5: Set the device description
    log "Setting device description: $DEVICE_DESCRIPTION"
    # Try pactl first, then fall back to pacmd
    if ! pactl set-sink-property "$DEVICE_NAME" device.description "\"$DEVICE_DESCRIPTION\"" 2>/dev/null; then
        if ! pacmd update-sink-proplist "$DEVICE_NAME" 'device.description="'"$DEVICE_DESCRIPTION"'"' &>/dev/null; then
            warning "Could not set device description (non-critical)"
        else
            log "Device description set via pacmd"
        fi
    else
        log "Device description set via pactl"
    fi
    
    # Verify the device was created with correct name
    if ! pactl list short sinks | grep -q "$DEVICE_NAME"; then
        error "Device creation verification failed - sink not found"
        pactl unload-module "$SINK_MODULE_ID" 2>/dev/null || true
        exit 1
    fi
    
    log "Verified device creation: $DEVICE_NAME"
    
    # Step 2: Create loopback so user hears audio through speakers
    log "Creating speaker loopback"
    LOOPBACK_MODULE_ID=$(pactl load-module module-loopback \
        source="$DEVICE_NAME.monitor" \
        sink="@DEFAULT_SINK@" \
        latency_msec=20)
    
    if [ -z "$LOOPBACK_MODULE_ID" ]; then
        error "Failed to create speaker loopback"
        # Clean up null-sink
        pactl unload-module "$SINK_MODULE_ID" 2>/dev/null || true
        exit 1
    fi
    
    log "Created loopback with module ID: $LOOPBACK_MODULE_ID"
    
    # Step 3: Save configuration
    save_config
    
    success "REW virtual audio device created successfully!"
    echo
    echo "ðŸ“‹ SETUP INSTRUCTIONS:"
    echo "1. In REW, go to Preferences > Soundcard"
    echo "2. Set Output Device to: '$DEVICE_DESCRIPTION'"
    echo "3. Audio will play through your speakers AND be available for capture"
    echo
    echo "ðŸ’¡ Device name: $DEVICE_NAME"
    echo "ðŸ’¡ Monitor source: $DEVICE_NAME.monitor"
}

# Remove the virtual device
remove_device() {
    log "Removing REW virtual audio device..."
    
    load_config
    
    local removed_something=false
    
    # Remove loopback first
    if [ -n "$LOOPBACK_MODULE_ID" ]; then
        if pactl unload-module "$LOOPBACK_MODULE_ID" 2>/dev/null; then
            log "Removed loopback module: $LOOPBACK_MODULE_ID"
            removed_something=true
        else
            warning "Could not remove loopback module: $LOOPBACK_MODULE_ID"
        fi
    fi
    
    # Remove null-sink
    if [ -n "$SINK_MODULE_ID" ]; then
        if pactl unload-module "$SINK_MODULE_ID" 2>/dev/null; then
            log "Removed null-sink module: $SINK_MODULE_ID"
            removed_something=true
        else
            warning "Could not remove null-sink module: $SINK_MODULE_ID"
        fi
    fi
    
    # Try alternative removal if config method failed
    if ! $removed_something; then
        warning "Config-based removal failed, trying alternative method..."
        
        # Find and remove any modules for our device
        local modules=$(pactl list short modules | grep "$DEVICE_NAME" | awk '{print $1}' | tac)
        
        if [ -n "$modules" ]; then
            for module_id in $modules; do
                if pactl unload-module "$module_id" 2>/dev/null; then
                    log "Removed module: $module_id"
                    removed_something=true
                fi
            done
        fi
    fi
    
    # Additional cleanup: remove any orphaned null sinks that match REW patterns
    if ! $removed_something; then
        warning "Trying to clean up any orphaned REW devices..."
        
        # Look for any REW-related sinks
        local rew_sinks=$(pactl list short sinks | grep -E "REW|rew" | awk '{print $1}')
        if [ -n "$rew_sinks" ]; then
            for sink_id in $rew_sinks; do
                # Find the module that owns this sink
                local owner_module=$(pactl list sinks | grep -A 20 "Sink #$sink_id" | grep "Owner Module:" | awk '{print $3}')
                if [ -n "$owner_module" ] && [ "$owner_module" != "n/a" ]; then
                    if pactl unload-module "$owner_module" 2>/dev/null; then
                        log "Removed orphaned REW sink module: $owner_module"
                        removed_something=true
                    fi
                fi
            done
        fi
    fi
    
    # Clean up config
    remove_config
    
    if $removed_something; then
        success "REW virtual audio device removed successfully!"
    else
        warning "No REW virtual audio device found to remove."
    fi
}

# Show device status
show_status() {
    local status=$(get_device_status)
    
    echo "REW Virtual Audio Device Status"
    echo "================================"
    echo "Device Name: $DEVICE_NAME"
    echo "Description: $DEVICE_DESCRIPTION"
    echo -n "Status: "
    
    case "$status" in
        "ACTIVE")
            echo -e "${GREEN}ACTIVE${NC} (audio is flowing)"
            ;;
        "READY")
            echo -e "${YELLOW}READY${NC} (device created, no audio)"
            ;;
        "NOT_FOUND")
            echo -e "${RED}NOT FOUND${NC} (device not created)"
            ;;
        *)
            echo -e "${RED}UNKNOWN${NC} ($status)"
            ;;
    esac
    
    echo
    
    if [ "$status" != "NOT_FOUND" ]; then
        echo "Available in these applications:"
        echo "â€¢ REW (Room EQ Wizard)"
        echo "â€¢ System sound settings"
        echo "â€¢ All audio applications"
        echo
        echo "Monitor source: $DEVICE_NAME.monitor"
        echo "(Use this for capturing/recording REW output)"
    else
        echo "Run '$0 create' to create the virtual device."
    fi
    
    echo
    
    # Show config info if available
    load_config
    if [ -n "$SINK_MODULE_ID" ] || [ -n "$LOOPBACK_MODULE_ID" ]; then
        echo "Module Information:"
        [ -n "$SINK_MODULE_ID" ] && echo "â€¢ Sink Module ID: $SINK_MODULE_ID"
        [ -n "$LOOPBACK_MODULE_ID" ] && echo "â€¢ Loopback Module ID: $LOOPBACK_MODULE_ID"
        echo "â€¢ Config file: $CONFIG_FILE"
    fi
}

# List all audio devices
list_devices() {
    echo "All Audio Output Devices"
    echo "========================"
    pactl list short sinks | while read -r line; do
        local id=$(echo "$line" | awk '{print $1}')
        local name=$(echo "$line" | awk '{print $2}')
        local status=$(echo "$line" | awk '{print $5}')
        
        if [ "$name" = "$DEVICE_NAME" ]; then
            echo -e "${GREEN}[$id]${NC} $name ${YELLOW}(REW Virtual Device)${NC} - $status"
        else
            echo "[$id] $name - $status"
        fi
    done
    
    echo
    echo "All Audio Input Sources"
    echo "======================="
    pactl list short sources | while read -r line; do
        local id=$(echo "$line" | awk '{print $1}')
        local name=$(echo "$line" | awk '{print $2}')
        local status=$(echo "$line" | awk '{print $5}')
        
        if [[ "$name" == *"$DEVICE_NAME.monitor"* ]]; then
            echo -e "${GREEN}[$id]${NC} $name ${YELLOW}(REW Monitor)${NC} - $status"
        else
            echo "[$id] $name - $status"
        fi
    done
}

# Comprehensive cleanup of all REW devices
cleanup_all_rew_devices() {
    local cleaned_something=false
    
    log "Scanning for all REW-related devices..."
    
    # Find all null sinks that might be REW-related
    local all_null_sinks=$(pactl list short modules | grep "module-null-sink" | awk '{print $1}')
    
    if [ -n "$all_null_sinks" ]; then
        for module_id in $all_null_sinks; do
            # Get the sink name for this module
            local sink_name=$(pactl list modules | grep -A 10 "Module #$module_id" | grep "sink_name=" | cut -d'"' -f2)
            
            if [[ "$sink_name" == *"REW"* ]] || [[ "$sink_name" == *"rew"* ]]; then
                log "Found REW null-sink module: $module_id (sink: $sink_name)"
                
                # Find and remove associated loopback modules
                local loopback_modules=$(pactl list short modules | grep "module-loopback" | grep "$sink_name.monitor" | awk '{print $1}')
                for lb_module in $loopback_modules; do
                    if pactl unload-module "$lb_module" 2>/dev/null; then
                        log "Removed associated loopback module: $lb_module"
                        cleaned_something=true
                    fi
                done
                
                # Remove the null-sink module
                if pactl unload-module "$module_id" 2>/dev/null; then
                    log "Removed REW null-sink module: $module_id"
                    cleaned_something=true
                fi
            fi
        done
    fi
    
    # Also try to remove any remaining REW sinks directly
    local rew_sinks=$(pactl list short sinks | grep -E "REW|rew" | awk '{print $1}')
    if [ -n "$rew_sinks" ]; then
        for sink_id in $rew_sinks; do
            local owner_module=$(pactl list sinks | grep -A 20 "Sink #$sink_id" | grep "Owner Module:" | awk '{print $3}')
            if [ -n "$owner_module" ] && [ "$owner_module" != "n/a" ]; then
                if pactl unload-module "$owner_module" 2>/dev/null; then
                    log "Removed remaining REW sink module: $owner_module"
                    cleaned_something=true
                fi
            fi
        done
    fi
    
    # Clean up config files
    remove_config
    
    if $cleaned_something; then
        success "REW device cleanup completed successfully!"
    else
        log "No REW devices found to clean up"
    fi
}

# Fix PulseAudio connection issues
fix_pulseaudio() {
    log "Checking PulseAudio daemon status..."
    
    if pulseaudio --check; then
        log "PulseAudio daemon is running"
        
        # Test connection
        if pactl info &> /dev/null; then
            success "PulseAudio connection is working"
            return 0
        else
            warning "PulseAudio daemon running but pactl cannot connect"
        fi
    else
        warning "PulseAudio daemon is not running"
    fi
    
    log "Restarting PulseAudio daemon..."
    
    # Kill any existing daemon
    pulseaudio --kill 2>/dev/null || true
    
    # Wait a moment
    sleep 2
    
    # Start daemon
    pulseaudio --start
    
    # Wait a moment for startup
    sleep 2
    
    # Test connection
    if pactl info &> /dev/null; then
        success "PulseAudio connection restored!"
        return 0
    else
        error "Failed to restore PulseAudio connection"
        return 1
    fi
}

# Show usage information
show_usage() {
    cat << EOF
REW PulseAudio Loopback Device Manager

Usage: $0 <command>

Commands:
    create      Create REW virtual audio device
    remove      Remove REW virtual audio device  
    status      Show device status
    list        List all audio devices
    restart     Remove and recreate device
    cleanup     Remove ALL REW devices (comprehensive cleanup)
    fix         Fix PulseAudio connection issues
    help        Show this help message

Examples:
    $0 create    # Create the virtual device for REW
    $0 status    # Check if device is active
    $0 remove    # Clean up when done

The virtual device '$DEVICE_NAME' will appear in:
â€¢ REW's output device selection
â€¢ System audio settings
â€¢ All audio applications

Audio sent to this device will:
â€¢ Play through your normal speakers
â€¢ Be available for capture/streaming
â€¢ Work with REW measurements
EOF
}

# Main script logic
main() {
    case "${1:-}" in
        "create")
            check_pulseaudio
            if device_exists; then
                warning "REW virtual device '$DEVICE_NAME' already exists!"
                echo
                show_status
                exit 0
            elif rew_devices_exist; then
                warning "Other REW devices detected in the system!"
                echo "Existing REW devices found:"
                pactl list short sinks | grep -i "rew" | while read -r line; do
                    local sink_name=$(echo "$line" | awk '{print $2}')
                    echo "  â€¢ $sink_name"
                done
                echo
                echo "Options:"
                echo "  1. Run '$0 cleanup' to remove all REW devices first"
                echo "  2. Run '$0 remove' to remove the configured device"
                echo "  3. Continue anyway (may cause conflicts)"
                echo
                read -p "Continue with creation anyway? [y/N]: " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    log "Device creation cancelled by user"
                    exit 0
                fi
            fi
            create_device
            ;;
        "remove"|"delete"|"cleanup")
            check_pulseaudio
            remove_device
            ;;
        "status")
            check_pulseaudio
            show_status
            ;;
        "list"|"ls")
            check_pulseaudio
            list_devices
            ;;
        "restart"|"recreate")
            check_pulseaudio
            log "Restarting REW virtual device..."
            remove_device
            sleep 1
            create_device
            ;;
        "cleanup")
            log "Performing comprehensive cleanup..."
            cleanup_all_rew_devices
            ;;
        "fix-pulseaudio"|"fix")
            log "Fixing PulseAudio connection issues..."
            fix_pulseaudio
            ;;
        "help"|"-h"|"--help")
            show_usage
            ;;
        "")
            show_usage
            exit 1
            ;;
        *)
            error "Unknown command: $1"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"